# 网关(路由)常见问题记录

:tw-1f1e8-1f1f3:
列出问题较多的地方和需要解决的场景以及思路,仅供各技术参考

## 授权

###普通应用校验流程（403,您没有该服务的访问权限）

在进行应用校验的流程中授权GUI界面会传X-API-KEY的参数给网关(由插件cep-service-acl处理)，给指定key授权，在加载授权根据对应的X-API-KEY 对应的ID去APIKEY-SERVICE表找不到时就会出现这种情况，具体代码参考如下：

```
  --普通应用校验流程
    ngx.log(ngx.DEBUG, "获取到X-API-KEY：" .. tostring(x_api_key) .. "，进入普通应用校验流程。请求服务的Code:" .. route_id)
    if type(x_api_key) ~= "string" then
        return kong.response.exit(403, "X-API-KEY 重复")
    end
       – 缓存方法获取k为"c2_apikey_result_" .. x_api_key 的key
       --如果找不到即执行 load_apikey_key 务必加载一个有效值放入缓存已第一个参数为键
      – 最后一个参数为倒数第二个方法的入参
    local apikey_result, err =
        kong.cache:get("c2_apikey_result_" .. x_api_key, {ttl = 60}, load_apikey_key, x_api_key)
    if err then –如果报错直接返回也就是没有加载到数据
        -- here we can deal with the error returned by the callback
        return responses.send_HTTP_INTERNAL_SERVER_ERROR("API-KEY加载出错，apikeyId = " .. x_api_key)
    end
       --如果 apikey_result 为false or nil 
    if not apikey_result then
        return kong.response.exit(403, "X-API-KEY[" .. x_api_key .. "]无效")
    end
       – 也就是从数据库apikeys表加载到了对应记录
    local appid = apikey_result.appid
    local is_system_app = apikey_result.system_app
    ngx.log(ngx.DEBUG, "[cep-service-acl]获取到appid：" .. tostring(appid))
    local appid_number = tonumber(appid)
    --appid 1~10为系统应用，免校验
    if (appid_number ~= nil and appid_number >= 0 and appid_number <= 10) or (is_system_app ~= nil and is_system_app == true)then
        inject_access_info(conf, x_api_key, appid)
    else
        local apikey_services_result, err =
            kong.cache:get(
            "c2_apikey_services_result_" .. apikey_result.id .. "-" .. route_id,
            {ttl = 60},
                      --通过前端传的route_id和上一步从cepkeys表加载的记录的id字段
(该字段一般与对应记录的appid对应)
            load_apikey_services_key,
            apikey_result.id,//两个入参
            route_id
        )
        if apikey_services_result == nil then
            return kong.response.exit(403, "您没有该服务的访问权限")
        else
            --校验通过，注入信息，成功放行
            inject_access_info(conf, x_api_key, apikey_result.appid)
        end
    end
else
local function load_apikey_key(apikey)
    ngx.log(ngx.NOTICE, "开始从数据库加载apikey,  apikey =  " .. tostring(apikey))
    local apikey_result, err = kong.db.cep_apikeys:select_by_key(apikey)
    ngx.log(ngx.NOTICE, "从数据库加载到的apikey为： " .. json.encode(apikey_result))
    if err then
        return nil, err
    end
    if not apikey_result then
        return nil, nil
    end
    return apikey_result, nil
end

```

**举例：**

- 链接:
  http://10.3.5.17:31401/apikeys/JMYaCeynRHijDdcG8axTBA/routes
- 请求参数:
![image-20200617043849645](/home/jackliang/.config/Typora/typora-user-images/image-20200617043849645.png)

例如中间的route_id和right的数据是对不上的，如上的代码很容易可以看出了，这里不赘述。
此时的route_id为M* 而这一截和数据库的cep_apikey_services表的数据是对不上的所以很容易理解。

**解决：**
1. 检查客户端数据是否对上
2. 由于适配是否接口有所修改
3. 检查服务端逻辑是否过期

# no Route matched with those values
一般这种情况我们可以先看一下kong的路由流程，如下图：
![image-20200617044625802](/home/jackliang/.config/Typora/typora-user-images/image-20200617044625802.png)

#### 可能的情况：
- 请求先匹配route(路由)对象的path字段如果匹配上了，在去匹配service应该一个服务对多个路由当找不到服务时或者擅自修改关联ID可能会出现此问题.

- 排除了网关本身的问题(包括数据问题)之后,就可以考虑了路由转发从定向的机制了，定向返回的path由upstream服务返回，再由kong本身匹配校验返回的path是否符合路由，如果没有则返回no route ,这个时候日志会正常打印返回的数据不会有任何error和warn(这可能也是本身代码的问题).

**举例：**
![image-20200617044831781](/home/jackliang/Downloads/Typora-linux-x64/image-20200617044831781.png)
![image-20200617044852901](/home/jackliang/Downloads/Typora-linux-x64/image-20200617044852901.png)


这个时候相当于请求是又网关转发，但是授权被绕过，由于授权没有通过，上游服务返回/login.jsp，在经过网关的后期route_validate 所以网关会返回一个no route XXX，因为/login.jsp是匹配不到任何已有的路由的 ,但是日志打印正常。

**解决:**
正常开启acl插件就可以了，切勿自己手动修改数据库插件的enabled 字段。
# xxx field unknown
![image-20200617045114175](/home/jackliang/Downloads/Typora-linux-x64/image-20200617045114175.png)
一般这种情况是因为传输的字段和kong后台的scheme对不上所导致，分几种情况，思路如下：
##### 第一：
首选排除kong官网的自己的接口，因为除了少部分接口和customlize的插件，基本都是基于kong的官方版本，在这一点上基本就是由于自己对kong官网字段不熟悉，举个例子：
![image-20200617045211636](/home/jackliang/.config/Typora/typora-user-images/image-20200617045211636.png)
以上为post接口插入route表的一条记录，但是有可能我们最近版本对其进行了修改字段名，有可能不一样(service_id=?),所以这种情况只要是兼容官方的开发，在不之情的情况下即可参考官网的字段解析策略，也就是上图，写法：service:{id:xxxx}即可快速解决问题，不兼容开发不再本文讨论。
##### 第二：
可能有些接手网关的开发人员或者测试人员等已经习惯了camel naming ,所以在调用kong的admin接口的时候有可能会出现以下的请求体：
{"name": "my-route", "protocols": ["http", "https"], "methods": ["GET", "POST"], "hosts": ["example.com", "foo.test"], "paths": ["/foo", "/bar"], "headers": {"x-another-header":["bla"], "x-my-header":["foo", "bar"]}, "httpsRedirectStatusCode": 426, "regexPriority": 0, "stripPath": true, "preserve_host": false, "tags": ["user-level", "low-priority"], "service": {"id":"af8330d3-dbdc-48bd-b1be-55b98608834b"} }
这样也会出现xxx field unknown这样的异常
##### 第三：
还有一种情况比如scheme 是没错的，但是数据库字段没改也有可能出现如上的情况。
###### ***定位此类问题思路如下***：

- 首先判断是否是官网提供的对象或者插件对象，如果是官网提供的那么可以直接看官网资料(我们现在的开发基本都是兼容官网的开发)，快速定位和解决问题，这一步无需看日志。

- 排除之后基本就可以定位到自定义插件或者自定义的修改过的官方的表(这种情况比较少见)，通过查看日志的异常栈定位到是那一个具体的插件或者那一个类的具体代码。

- 排除逻辑拼接字段有可能导致的异常，例如cep_apikey_services 表的key字段就是由apikeyid和route_id拼接而成。

- 第三步没有问题就可以基本断定问题出在插件的schema上了，检查一下对应插件的字段是否在对应数据库表有正确的映射。

- 如果映射没问题那么可以缩小问题，猜测问题点应该是在对应插件schema的语法和配置上，对照官网修改即可。

- 如果以上都走完了还是有问题，麻烦重启网关。

以上流程可以解决日常报错的大部分问题。

# ##### xxxx concurrent request function various  xxxxx warning	
此警告意思就是为了兼容版本提示你某些方法需要定义local ，因为在多个shm之间进行了数据共享，对应一般在多个文件使用的工具类方法，如下写法：
![image-20200617045633969](/home/jackliang/.config/Typora/typora-user-images/image-20200617045633969.png)

# local  xxxx nil value  xxxx
此类问题意思定位其实很简单，日志看到这样的报错可以理解为是某一行代码的语法错误导致，对应日志定位到某一行代码，看一下为什么是nil即可，一般进行了nil判断或者初始化local的赋值和懒加载之后就不会出现这样的问题.